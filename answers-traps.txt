1.在RISC-V架构中，函数参数保存在`a0`到`a7`寄存器中
2.没有调用f函数对应的汇编源码，因为g(x) 被内联到 f(x) 中，然后 f(x) 又被进一步内联到 main() 中
3.`auipc`(Add Upper Immediate to PC)得到pc的值**0x30**存储在`ra`寄存器，`jalr`(jump and link register)指令跳转到`ra`寄存器的值并加上偏移量1536（即**0x600**），所以`printf`的地址是**0x630**
4.对比指令格式，这行代码将0x0左移12位（还是0x0）加到pc（当前为0x30）并存入ra中，即ra中保存的是0x30
5.57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表：72:r 6c:l 64:d 00:充当字符串结尾标识

因此输出为：HE110 World

若为大端存储，i应改为0x726c6400，不需改变57616
6.原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据。
